{"version":3,"sources":["libs/board.js"],"names":["derives","STATE_GOING","STATE_BLACK_WIN","STATE_WHITE_WIN","STATE_FORBIDDEN","STATE_DRAW","Board","fieldText","FIELD_BLACK","FIELD_WHITE","field","width","height","nInRow","log","action","clear","board","map","Array","fill","FIELD_BLANK","order","currentOrder","nextField","state","BOARD_STATE_GOING","file","places","JSON","parse","readFileSync","toString","e","UserError","fieldStat","forEach","place","x","y","row","push","getOppositeField","position","move","ended","fieldStr","addStone","BOARD_STATE_DRAW","BOARD_STATE_WIN_BLACK","BOARD_STATE_WIN_WHITE","info"],"mappings":"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","file":"board.js","sourcesContent":["import fs from 'fs';\nimport assert from 'assert';\nimport _ from 'lodash';\n\nimport errors from './errors';\nimport utils from './utils';\nimport finder from '../../build/Release/forbidden-point-finder';\n\nconst derives = [[0, 1], [1, 0], [1, 1], [1, -1]];\n\nconst STATE_GOING = -1;\nconst STATE_BLACK_WIN = 0;\nconst STATE_WHITE_WIN = 1;\nconst STATE_FORBIDDEN = 2;\nconst STATE_DRAW = 3;\n\nexport default class Board {\n\n  static FIELD_BLANK = 0;\n  static FIELD_BLACK = 1;\n  static FIELD_WHITE = 2;\n\n  static BOARD_STATE_GOING = 0;\n  static BOARD_STATE_WIN_BLACK = 1;\n  static BOARD_STATE_WIN_WHITE = 2;\n  static BOARD_STATE_DRAW = 3;\n\n  static translateField(fieldText) {\n    assert(fieldText === 'black' || fieldText === 'white');\n    if (fieldText === 'black') {\n      return Board.FIELD_BLACK;\n    } else if (fieldText === 'white') {\n      return Board.FIELD_WHITE;\n    }\n  }\n\n  static getOppositeField(field) {\n    assert(field === Board.FIELD_BLACK || field === Board.FIELD_WHITE);\n    if (field === Board.FIELD_BLACK) {\n      return Board.FIELD_WHITE;\n    } else if (field === Board.FIELD_WHITE) {\n      return Board.FIELD_BLACK;\n    }\n  }\n\n  constructor(width, height, nInRow) {\n    assert(width > 0);\n    assert(height > 0);\n    assert(nInRow > 1);\n    utils.log('debug', {action: 'createBoard', width, height, nInRow});\n    this.width = width;\n    this.height = height;\n    this.nInRow = nInRow;\n    this.clear();\n    finder.clear();\n  }\n\n  clear() {\n    this.board = _.map(new Array(this.height),\n      row => _.fill(new Array(this.width), Board.FIELD_BLANK));\n    this.order = _.map(new Array(this.height),\n      row => _.fill(new Array(this.width), 0));\n    this.currentOrder = 0;\n    this.nextField = Board.FIELD_BLACK;\n    this.state = Board.BOARD_STATE_GOING;\n  }\n\n  clearFromFile(file) {\n    this.clear();\n    let places;\n    try {\n      places = JSON.parse(fs.readFileSync(file).toString());\n    } catch (e) {\n      throw new errors.UserError('Failed to read or parse the file.');\n    }\n    const fieldStat = {\n      [Board.FIELD_BLACK]: 0,\n      [Board.FIELD_WHITE]: 0,\n    };\n    places.forEach(place => {\n      const [x, y, field] = place;\n      if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n        throw new errors.UserError(`Invalid place at (${x}, ${y})`);\n      }\n      if (field !== Board.FIELD_BLACK && field !== Board.FIELD_WHITE) {\n        throw new errors.UserError(`Invalid field value ${field}`);\n      }\n      if (this.board[y][x] !== Board.FIELD_BLANK) {\n        throw new errors.UserError(`Duplicate place at (${x}, ${y})`);\n      }\n      this.board[y][x] = field;\n      fieldStat[field]++;\n    });\n    if (fieldStat[Board.FIELD_BLACK] === fieldStat[Board.FIELD_WHITE]) {\n      this.nextField = Board.FIELD_BLACK;\n    } else if (fieldStat[Board.FIELD_BLACK] === fieldStat[Board.FIELD_WHITE] +\n      1) {\n      this.nextField = Board.FIELD_WHITE;\n    } else {\n      throw new errors.UserError(\n        `Invalid initial state, black = ${fieldStat[Board.FIELD_BLACK]}, white = ${fieldStat[Board.FIELD_WHITE]}.`);\n    }\n    utils.log('debug',\n      {action: 'clearBoard', board: this.board, nextField: this.nextField});\n  }\n\n  getCurrentPlaces() {\n    const places = [];\n    this.board.forEach((row, y) => {\n      row.forEach((field, x) => {\n        if (field !== Board.FIELD_BLANK) {\n          places.push({x, y, field});\n        }\n      });\n    });\n    return places;\n  }\n\n  place(x, y) {\n    assert(this.state === Board.BOARD_STATE_GOING);\n\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      throw new errors.UserError(\n        `Invalid move. Movement position out of board.`);\n    }\n    if (this.board[y][x] !== Board.FIELD_BLANK) {\n      throw new errors.UserError(\n        `Invalid move. There is already a stone at position (${x}, ${y}).`);\n    }\n\n    const field = this.nextField;\n    this.board[y][x] = field;\n    this.order[y][x] = ++this.currentOrder;\n    this.nextField = Board.getOppositeField(field);\n\n    utils.log('debug', {action: 'place', position: [x, y], field});\n\n    const move = {x, y, ended: false};\n    //const [ state, winningStones ] = this.getCurrentState(x, y, field);\n\n    const fieldStr = field === Board.FIELD_BLACK ? 'black' : 'white';\n    const state = finder.addStone(x, y, fieldStr);\n\n    if (state === STATE_DRAW) {\n      move.ended = true;\n      this.state = Board.BOARD_STATE_DRAW;\n    } else if (state === STATE_BLACK_WIN) {\n      move.ended = true;\n      this.state = Board.BOARD_STATE_WIN_BLACK;\n    } else if (state === STATE_WHITE_WIN || state === STATE_FORBIDDEN) {\n      move.ended = true;\n      this.state = Board.BOARD_STATE_WIN_WHITE;\n    }\n\n    if (move.ended) {\n      const info = {action: 'roundEnd', board: this.board};\n      // if (state === STATE_WIN) {\n      //   info.winningStones = winningStones;\n      // }\n      utils.log('debug', info);\n    }\n\n    return move;\n  }\n\n  /*\n    getCurrentState(x, y, field) {\n      for (const [dx, dy] of derives) {\n        let count = 1;\n        let x0, y0;\n        let stones = [[x, y]];\n        for (const dir of [1, -1]) {\n          x0 = x + dir * dx;\n          y0 = y + dir * dy;\n          while (x0 >= 0 && x0 < this.width && y0 >= 0 && y0 < this.height && this.board[y0][x0] === field) {\n            count++;\n            stones.push([x0, y0]);\n            x0 += dir * dx;\n            y0 += dir * dy;\n          }\n        }\n        if (count >= this.nInRow) {\n          return [STATE_WIN, stones];\n        }\n      }\n      for (const row of this.board) {\n        for (const field of row) {\n          if (field === Board.FIELD_BLANK) {\n            return [STATE_GOING];\n          }\n        }\n      }\n      return [STATE_DRAW];\n    }\n  */\n\n}\n"]}